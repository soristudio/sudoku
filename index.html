<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ìŠ¤ë„ì¿  ìƒì„±ê¸°</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <h1>ìŠ¤ë„ì¿  ìƒì„±ê¸°</h1>
  <div class="meta" id="date"></div>

  <div class="controls">
    <label for="difficulty">ë‚œì´ë„:</label>
    <select id="difficulty">
      <option value="easy">ì‰¬ì›€</option>
      <option value="medium">ë³´í†µ</option>
      <option value="hard">ì–´ë ¤ì›€</option>
      <option value="expert">ì „ë¬¸ê°€</option>
      <option value="evil">ì•…ë§ˆ</option>
    </select>
        
    <button onclick="generateSudoku()">ìƒˆ í¼ì¦ ìƒì„±</button>
<label class="switch">
    <span class="label-text">ê°€ì´ë“œ</span>
  <input type="checkbox" id="guide-toggle" checked />
  <span class="slider"></span>

</label>
  </div>


  <div class="sudoku-board" id="board"></div>

  <div id="pencil-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="modal-label" aria-describedby="modal-desc">
  <div class="modal-content">
    <h2 id="modal-label">ë©”ëª¨ ì…ë ¥ (ì˜ˆ: 137)</h2>
    <input type="text" id="pencil-input" maxlength="9" autocomplete="off" />
    <div class="modal-buttons">
      <button id="modal-ok" class="btn-primary">í™•ì¸</button>
      <button id="modal-cancel" class="btn-secondary">ì·¨ì†Œ</button>
    </div>
  </div>
</div>

  <div class="z_footer_copyright">
    Powered by
    <a href="https://x.com/zenless_x" target="_blank" rel="noopener noreferrer" class="powered-link">
      zenn
    </a>
  </div>

  <script>
    const boardElement = document.getElementById('board');

    function createEmptyBoard(puzzleBoard = null) {
      boardElement.innerHTML = '';
      for (let i = 0; i < 81; i++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');

        const row = Math.floor(i / 9);
        const col = i % 9;
        const blockRow = Math.floor(row / 3);
        const blockCol = Math.floor(col / 3);

        // 3x3 ë¸”ë¡ ë°°ê²½ êµì°¨ ìƒ‰ìƒ
        if ((blockRow + blockCol) % 2 === 0) {
          cell.classList.add('block-light');
        } else {
          cell.classList.add('block-dark');
        }

        const valueDiv = document.createElement('div');
        valueDiv.classList.add('value');
        cell.appendChild(valueDiv);

        if (puzzleBoard && puzzleBoard[row][col] !== 0) {
          cell.classList.add('fixed');
          valueDiv.textContent = puzzleBoard[row][col];
        } else {
          cell.addEventListener('click', (e) => handleLeftClick(e, cell));
          cell.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            handleRightClick(e, cell);
          });
        }

        boardElement.appendChild(cell);
      }
      validateBoard(); // ì´ˆê¸° ìƒíƒœ ê²€ì¦
    }

    function handleLeftClick(e, cell) {
  if (cell.classList.contains('fixed')) return;

  // ğŸ“Œ valueDivê°€ ì—†ìœ¼ë©´ ìƒì„±
  let valueDiv = cell.querySelector('.value');
  if (!valueDiv) {
    valueDiv = document.createElement('div');
    valueDiv.classList.add('value');
    cell.appendChild(valueDiv);
  }

  if (valueDiv.isContentEditable) return;

  valueDiv.setAttribute('contenteditable', 'true');
  valueDiv.focus();
  selectAllText(valueDiv);

  // ğŸ‘‰ ì‹¤ì‹œê°„ í•„í„°ë§: ìˆ«ì 1ê°œë§Œ ì…ë ¥ë˜ë„ë¡
  const onInput = () => {
    const clean = valueDiv.textContent.replace(/[^1-9]/g, '');
    if (clean.length > 1) {
      valueDiv.textContent = clean.charAt(0);
      placeCaretAtEnd(valueDiv);
    } else {
      valueDiv.textContent = clean;
    }
  };

  // ğŸ‘‰ ì…ë ¥ ì™„ë£Œ ì‹œ ì²˜ë¦¬
  const finishEdit = () => {
    const text = valueDiv.textContent.trim();
    if (/^[1-9]$/.test(text)) {
      valueDiv.textContent = text;
      cell.classList.add('user-input');
    } else {
      valueDiv.textContent = '';
      cell.classList.remove('user-input');
    }

    valueDiv.removeAttribute('contenteditable');
    valueDiv.removeEventListener('input', onInput);
    valueDiv.removeEventListener('blur', finishEdit);
    valueDiv.removeEventListener('keydown', onKeyDown);

    clearPencilNotes(cell);
    cell.classList.remove('pencil');

    saveProgressToLocal();
    validateBoard();
    saveAfterChange();
    updatePencilGuide?.(guideToggle?.checked); // ê°€ì´ë“œ ê°±ì‹  (ì„ íƒì )
  };

  const onKeyDown = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      finishEdit();
      cell.focus();
    }
  };

  valueDiv.addEventListener('input', onInput);
  valueDiv.addEventListener('blur', finishEdit);
  valueDiv.addEventListener('keydown', onKeyDown);
}



    // ì˜¤ë¥¸ìª½ í´ë¦­ - íœìŠ¬ ëª¨ë“œ ì…ë ¥ (prompt)
    function handleRightClick(e, cell) {
if (cell.classList.contains('fixed')) return;

openPencilModal((input) => {
  if (input === null) return;

  const digits = input.replace(/[^1-9]/g, '');
  clearPencilNotes(cell);
  cell.classList.remove('user-input');

  let valueDiv = cell.querySelector('.value');
  if (!valueDiv) {
    valueDiv = document.createElement('div');
    valueDiv.classList.add('value');
    cell.appendChild(valueDiv);
  }
  valueDiv.textContent = '';

  if (digits.length > 0) {
    cell.classList.add('pencil');

    const SLOT_SIZE = 100 / 3;             // 33.33...%
    const HALF_SLOT = SLOT_SIZE / 2;       // ì¤‘ì•™ ì •ë ¬ìš©
    const TOP_BIAS = 0;                    // ìƒë‹¨ ë³´ì •ìš© (í¼ì„¼íŠ¸ ë‹¨ìœ„)

    for (let char of digits) {
      const n = parseInt(char) - 1;
      const mark = document.createElement('span');
      mark.textContent = char;

      // ìœ„ì¹˜ ê³„ì‚° (ì™¼ìª½, ìœ„ìª½ ëª¨ë‘ ì¤‘ì•™ ê¸°ì¤€ + ë³´ì •)
      mark.style.left = `${(n % 3) * SLOT_SIZE + HALF_SLOT}%`;
      mark.style.top = `${Math.floor(n / 3) * SLOT_SIZE + HALF_SLOT + TOP_BIAS}%`;
      mark.style.transform = 'translate(-50%, -50%)';

      cell.appendChild(mark);
    }
  } else {
    cell.classList.remove('pencil');
  }

  validateBoard();
  saveAfterChange();

  // ì—¬ê¸°ì„œ ë©”ëª¨ ê°€ì´ë“œ ìƒíƒœì— ë”°ë¥¸ ì¤‘ë³µ í‘œì‹œ ê°±ì‹ 
  updatePencilGuide(guideToggle.checked);
});
    }



    function clearPencilNotes(cell) {
      const spans = cell.querySelectorAll('span');
      spans.forEach(s => s.remove());
      cell.classList.remove('pencil');
    }

    // ê²€ì¦ í•¨ìˆ˜ (ì¤‘ë³µ ìˆ«ì ì²´í¬)
    function validateBoard() {
      const cells = boardElement.querySelectorAll('.cell');
      const cellsArray = Array.from(cells);

      // ì˜¤ë¥˜ í´ë˜ìŠ¤ ëª¨ë‘ ì´ˆê¸°í™”
      cellsArray.forEach(cell => cell.classList.remove('error'));

      // 9x9 ìˆ«ì ë°°ì—´ ì´ˆê¸°í™”
      const board = Array.from({ length: 9 }, () => Array(9).fill(null));

      cellsArray.forEach((cell, idx) => {
        const row = Math.floor(idx / 9);
        const col = idx % 9;
        const valueDiv = cell.querySelector('.value');
        let val = valueDiv ? valueDiv.textContent.trim() : '';
        if (/^[1-9]$/.test(val)) {
          board[row][col] = val;
        }
      });

      const duplicates = [];

      // í–‰ ì¤‘ë³µ ì²´í¬
      for (let r = 0; r < 9; r++) {
        const counts = {};
        for (let c = 0; c < 9; c++) {
          const v = board[r][c];
          if (v) {
            if (counts[v]) counts[v].push([r, c]);
            else counts[v] = [[r, c]];
          }
        }
        Object.values(counts).forEach(arr => {
          if (arr.length > 1) duplicates.push(...arr);
        });
      }

      // ì—´ ì¤‘ë³µ ì²´í¬
      for (let c = 0; c < 9; c++) {
        const counts = {};
        for (let r = 0; r < 9; r++) {
          const v = board[r][c];
          if (v) {
            if (counts[v]) counts[v].push([r, c]);
            else counts[v] = [[r, c]];
          }
        }
        Object.values(counts).forEach(arr => {
          if (arr.length > 1) duplicates.push(...arr);
        });
      }

      // 3x3 ë°•ìŠ¤ ì¤‘ë³µ ì²´í¬
      for (let boxRow = 0; boxRow < 3; boxRow++) {
        for (let boxCol = 0; boxCol < 3; boxCol++) {
          const counts = {};
          for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
              const row = boxRow * 3 + r;
              const col = boxCol * 3 + c;
              const v = board[row][col];
              if (v) {
                if (counts[v]) counts[v].push([row, col]);
                else counts[v] = [[row, col]];
              }
            }
          }
          Object.values(counts).forEach(arr => {
            if (arr.length > 1) duplicates.push(...arr);
          });
        }
      }

      // ì¤‘ë³µëœ ì…€ë“¤ì— error í´ë˜ìŠ¤ ì¶”ê°€
      duplicates.forEach(([r, c]) => {
        const idx = r * 9 + c;
        cellsArray[idx].classList.add('error');
      });

      // ë¹ˆ ì¹¸ì´ ìˆëŠ”ì§€ í™•ì¸
      const hasEmpty = cellsArray.some(cell => {
        const valueDiv = cell.querySelector('.value');
        const val = valueDiv ? valueDiv.textContent.trim() : '';
        return !/^[1-9]$/.test(val);
      });

      // ì¤‘ë³µì´ ì—†ê³  ë¹ˆì¹¸ë„ ì—†ìœ¼ë©´ ì™„ì„±
      if (!hasEmpty && duplicates.length === 0) {
        setTimeout(() => {
          alert("ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! í¼ì¦ì„ ëª¨ë‘ ë§ì¶”ì…¨ìŠµë‹ˆë‹¤!");
        }, 100);
      }
    }


    // ì´í•˜ ê¸°ì¡´ generate, solve, URL í•¨ìˆ˜ ë“± ë™ì¼í•˜ë¯€ë¡œ ìƒëµ

    function isSafe(board, row, col, num) {
      for (let x = 0; x < 9; x++) {
        if (board[row][x] === num || board[x][col] === num) return false;
      }
      const startRow = row - (row % 3);
      const startCol = col - (col % 3);
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          if (board[startRow + i][startCol + j] === num) return false;
        }
      }
      return true;
    }

    function solveBoard(board) {
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          if (board[row][col] === 0) {
            let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            nums.sort(() => Math.random() - 0.5);
            for (let num of nums) {
              if (isSafe(board, row, col, num)) {
                board[row][col] = num;
                if (solveBoard(board)) return true;
                board[row][col] = 0;
              }
            }
            return false;
          }
        }
      }
      return true;
    }

    function generateFullBoard() {
      const board = Array.from({ length: 9 }, () => Array(9).fill(0));
      solveBoard(board);
      return board;
    }

    function removeCells(board, clues = 35) {
      const newBoard = board.map(row => row.slice());
      let count = 81 - clues;
      while (count > 0) {
        const r = Math.floor(Math.random() * 9);
        const c = Math.floor(Math.random() * 9);
        if (newBoard[r][c] !== 0) {
          newBoard[r][c] = 0;
          count--;
        }
      }
      return newBoard;
    }

    function boardToString(board) {
      return board.flat().join('');
    }

    function stringToBoard(str) {
      const nums = str.split('').map(Number);
      const board = [];
      for (let i = 0; i < 9; i++) {
        board.push(nums.slice(i * 9, i * 9 + 9));
      }
      return board;
    }

    function updateURL(board, difficulty) {
      const puzzleStr = boardToString(board);
      const url = new URL(window.location.href);
      url.searchParams.set('puzzle', puzzleStr);
      url.searchParams.set('difficulty', difficulty);
      history.replaceState(null, '', url);
    }

    function getClueCount(difficulty) {
      switch (difficulty) {
        case 'easy': return 40;
        case 'medium': return 32;
        case 'hard': return 25;
        case 'expert': return 20;
        case 'evil': return 17;
        default: return 35;
      }
    }

    function displayToday() {
      const today = new Date().toISOString().slice(0, 10);
      document.getElementById('date').textContent = `ğŸ“… ì˜¤ëŠ˜ì˜ í¼ì¦: ${today}`;
    }

    function loadPuzzleFromQuery() {
      const params = new URLSearchParams(window.location.search);
      const puzzleStr = params.get('puzzle');
      const difficulty = params.get('difficulty') || 'easy';

      document.getElementById('difficulty').value = difficulty;

      if (puzzleStr && puzzleStr.length === 81) {
        const board = stringToBoard(puzzleStr);
        createEmptyBoard(board);
        displayToday();
        loadProgressFromLocal();
        return true;
      }
      return false;
    }

    function generateSudoku() {
      const difficulty = document.getElementById('difficulty').value;
      const full = generateFullBoard();
      const clues = getClueCount(difficulty);
      const puzzle = removeCells(full, clues);
      createEmptyBoard(puzzle);
      updateURL(puzzle, difficulty);
      displayToday();
      loadProgressFromLocal();
    }

    function saveProgressToLocal() {
      const params = new URLSearchParams(location.search);
      const puzzleStr = params.get('puzzle');
      if (!puzzleStr) return;

      const cells = document.querySelectorAll('.cell');
      const values = Array.from(cells).map(cell => {
        const val = cell.querySelector('.value')?.textContent.trim() || '';
        return val;
      });

      localStorage.setItem(`sudoku-progress-${puzzleStr}`, JSON.stringify(values));
    }

    function loadProgressFromLocal() {
      const params = new URLSearchParams(location.search);
      const puzzleStr = params.get('puzzle');
      if (!puzzleStr) return;

      const saved = localStorage.getItem(`sudoku-progress-${puzzleStr}`);
      if (!saved) return;

      const values = JSON.parse(saved);
      const cells = document.querySelectorAll('.cell');
      values.forEach((val, i) => {
        const cell = cells[i];
        const valueDiv = cell.querySelector('.value');
        if (!cell.classList.contains('fixed') && valueDiv) {
          valueDiv.textContent = val;
          if (/^[1-9]$/.test(val)) {
            cell.classList.add('user-input');
          } else {
            cell.classList.remove('user-input');
          }
        }
      });
    }


    function updateURLWithInputs() {
      const cells = document.querySelectorAll('.cell');
      let inputStr = '';
      cells.forEach(cell => {
        const val = cell.querySelector('.value')?.textContent.trim() || '.';
        inputStr += /^[1-9]$/.test(val) ? val : '.';
      });
      const url = new URL(location.href);
      url.searchParams.set('inputs', inputStr);
      history.replaceState(null, '', url);
    }

    function loadInputsFromURL() {
      const inputStr = new URLSearchParams(location.search).get('inputs');
      if (!inputStr || inputStr.length !== 81) return;

      const cells = document.querySelectorAll('.cell');
      [...inputStr].forEach((char, i) => {
        const cell = cells[i];
        const valueDiv = cell.querySelector('.value');
        if (!cell.classList.contains('fixed') && valueDiv) {
          if (char !== '.' && /^[1-9]$/.test(char)) {
            valueDiv.textContent = char;
            cell.classList.add('user-input');
          } else {
            valueDiv.textContent = '';
            cell.classList.remove('user-input');
          }
        }
      });
    }

    function selectAllText(el) {
      el.focus();
      if (window.getSelection && document.createRange) {
        const range = document.createRange();
        range.selectNodeContents(el);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      } else if (document.body.createTextRange) {
        const textRange = document.body.createTextRange();
        textRange.moveToElementText(el);
        textRange.select();
      }
    }

    const undoStack = [];
    const redoStack = [];
    const MAX_STACK_SIZE = 100;

    function saveState() {
      const cells = boardElement.querySelectorAll('.cell');
      let state = [];
      cells.forEach(cell => {
        const valueDiv = cell.querySelector('.value');
        let val = valueDiv ? valueDiv.textContent.trim() : '';
        let pencil = '';
        if (cell.classList.contains('pencil')) {
          pencil = Array.from(cell.querySelectorAll('span')).map(s => s.textContent).join('');
        }
        state.push({ val, pencil });
      });
      undoStack.push(state);
      if (undoStack.length > MAX_STACK_SIZE) undoStack.shift();

      // ìƒˆ ìƒíƒœ ì €ì¥ ì‹œ redo ê¸°ë¡ ì´ˆê¸°í™”
      redoStack.length = 0;
    }

    function restoreState(state) {
      const cells = boardElement.querySelectorAll('.cell');
      cells.forEach((cell, idx) => {
        const data = state[idx];

        cell.classList.remove('user-input', 'pencil', 'error');
        clearPencilNotes(cell);

        let valueDiv = cell.querySelector('.value');
        if (!valueDiv) {
          valueDiv = document.createElement('div');
          valueDiv.classList.add('value');
          cell.appendChild(valueDiv);
        }

        valueDiv.textContent = '';

        if (data.val) {
          valueDiv.textContent = data.val;

          // fixed ì…€ì´ ì•„ë‹ˆë©´ user-input ë¶™ì„
          if (!cell.classList.contains('fixed')) {
            cell.classList.add('user-input');
          }
        }

        if (data.pencil && data.pencil.length > 0) {
          cell.classList.add('pencil');
          for (let char of data.pencil) {
            const n = parseInt(char) - 1;
            const mark = document.createElement('span');
            mark.style.left = `${(n % 3) * 16}px`;
            mark.style.top = `${Math.floor(n / 3) * 16}px`;
            mark.textContent = char;
            cell.appendChild(mark);
          }
        }
      });
      validateBoard();
    }


    function saveAfterChange() {
      saveState();
    }

    // Undo ì´ë²¤íŠ¸ ì²˜ë¦¬
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        if (undoStack.length > 1) {
          const currentState = undoStack.pop();
          redoStack.push(currentState);
          const prevState = undoStack[undoStack.length - 1];
          restoreState(prevState);
        }
      }
    });

    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && e.shiftKey) {
        e.preventDefault();
        if (redoStack.length > 0) {
          const nextState = redoStack.pop();
          undoStack.push(nextState);
          restoreState(nextState);
        }
      }
    });

    function openPencilModal(callback) {
  const modal = document.getElementById('pencil-modal');
  const input = document.getElementById('pencil-input');
  const okBtn = document.getElementById('modal-ok');
  const cancelBtn = document.getElementById('modal-cancel');

  modal.classList.remove('hidden');
  input.value = '';
  input.focus();

  const handleOk = () => {
    cleanup();
    callback(input.value);
     updatePencilGuide(guideToggle.checked);
     console.log(guideToggle.checked)
  };

  const handleCancel = () => {
    cleanup();
    callback(null);
  };

  const handleKey = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleOk();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      handleCancel();
    }
  };

  const cleanup = () => {
    modal.classList.add('hidden');
    okBtn.removeEventListener('click', handleOk);
    cancelBtn.removeEventListener('click', handleCancel);
    document.removeEventListener('keydown', handleKey);
  };

  okBtn.addEventListener('click', handleOk);
  cancelBtn.addEventListener('click', handleCancel);
  document.addEventListener('keydown', handleKey);
}


const guideToggle = document.getElementById('guide-toggle');

function loadGuideToggleState() {
  const saved = localStorage.getItem('sudoku-guide-toggle');
  if (saved === 'off') {
    guideToggle.checked = false;
  } else {
    guideToggle.checked = true; // ê¸°ë³¸ ON
  }
  updatePencilGuide?.(guideToggle.checked);
}


guideToggle.addEventListener('change', () => {
  const state = guideToggle.checked ? 'on' : 'off';
  localStorage.setItem('sudoku-guide-toggle', state);
  updatePencilGuide?.(guideToggle.checked);
  validatePencilNotes();
});

function validatePencilNotes() {
  const guideOn = guideToggle.checked;
  const cells = boardElement.querySelectorAll('.cell');

  // 1) í˜„ì¬ ë³´ë“œì—ì„œ í™•ì •ê°’ ìˆ˜ì§‘
  // í™•ì •ê°’ ë°°ì—´ (9x9) - fixed ë˜ëŠ” user-input ìˆ«ì
  const confirmed = Array.from({ length: 9 }, () => Array(9).fill(null));
  cells.forEach((cell, idx) => {
    const row = Math.floor(idx / 9);
    const col = idx % 9;
    if (cell.classList.contains('fixed') || cell.classList.contains('user-input')) {
      const val = cell.querySelector('.value')?.textContent.trim();
      if (/^[1-9]$/.test(val)) {
        confirmed[row][col] = val;
      }
    }
  });

  // 2) ê°€ì´ë“œ ONì¸ ê²½ìš° íœìŠ¬ ìˆ«ì ì¤‘ ì‹¤ì œ ë¶ˆê°€ëŠ¥í•œ ìˆ«ì ë¹¨ê°„ìƒ‰ í‘œì‹œ
  cells.forEach((cell, idx) => {
    if (!cell.classList.contains('pencil')) {
      // íœìŠ¬ ì—†ëŠ” ì…€ì€ ë¹¨ê°„ í‘œì‹œ ì œê±°
      cell.querySelectorAll('span').forEach(span => {
        span.style.color = '';
      });
      return;
    }
    const row = Math.floor(idx / 9);
    const col = idx % 9;

    cell.querySelectorAll('span').forEach(span => {
      const digit = span.textContent;
      if (!guideOn) {
        // ê°€ì´ë“œ OFFë©´ ìƒ‰ìƒ ì´ˆê¸°í™”
        span.style.color = '';
        return;
      }

      // digitì´ í™•ì •ê°’ê³¼ ì¤‘ë³µì¸ì§€ ê²€ì‚¬ (ê°™ì€ í–‰, ì—´, ë¸”ë¡ í™•ì¸)
      const conflict = isDigitConflict(confirmed, row, col, digit);

      if (conflict) {
        span.style.color = 'red';
      } else {
        span.style.color = '';
      }
    });
  });
}

// í™•ì •ê°’ ë°°ì—´ ê¸°ì¤€ìœ¼ë¡œ digitì´ row, col ìœ„ì¹˜ì—ì„œ ì“¸ ìˆ˜ ì—†ëŠ” ìˆ«ìì¸ì§€ ê²€ì‚¬
function isDigitConflict(confirmed, row, col, digit) {
  // í–‰ ê²€ì‚¬
  for (let c = 0; c < 9; c++) {
    if (c !== col && confirmed[row][c] === digit) return true;
  }
  // ì—´ ê²€ì‚¬
  for (let r = 0; r < 9; r++) {
    if (r !== row && confirmed[r][col] === digit) return true;
  }
  // 3x3 ë¸”ë¡ ê²€ì‚¬
  const startRow = Math.floor(row / 3) * 3;
  const startCol = Math.floor(col / 3) * 3;
  for (let r = startRow; r < startRow + 3; r++) {
    for (let c = startCol; c < startCol + 3; c++) {
      if ((r !== row || c !== col) && confirmed[r][c] === digit) return true;
    }
  }
  return false;
}


function updatePencilGuide(isGuideOn) {
  const cells = boardElement.querySelectorAll('.cell');

  cells.forEach(cell => {
    // ì¼ë‹¨ ê¸°ì¡´ ë¹¨ê°„ìƒ‰ í‘œì‹œ ì´ˆê¸°í™”
    const pencilSpans = cell.querySelectorAll('span');
    pencilSpans.forEach(span => {
      span.style.color = ''; // ê¸°ë³¸ ìƒ‰ìƒìœ¼ë¡œ ì´ˆê¸°í™”
    });

    if (!isGuideOn) return; // ê°€ì´ë“œ êº¼ì ¸ìˆìœ¼ë©´ ë¹¨ê°„ìƒ‰ í‘œì‹œ ì•ˆí•¨

    if (!cell.classList.contains('pencil')) return;

    // í˜„ì¬ ì…€ì— ì íŒ íœìŠ¬ ìˆ«ìë“¤
    const pencilNums = Array.from(pencilSpans).map(s => s.textContent);

    // í•´ë‹¹ ìˆ«ìë“¤ ì¤‘ì— ì‹¤ì œ ë³´ë“œ ë‚´ì—ì„œ ì¤‘ë³µëœ ìˆ«ìë¥¼ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ í‘œì‹œí•´ì•¼ í•¨
    // ì¤‘ë³µëœ ìˆ«ì êµ¬í•˜ê¸° ìœ„í•´ ë³´ë“œ ì „ì²´ íœìŠ¬ ìˆ«ì ì¹´ìš´íŠ¸ ê³„ì‚°

    // ëª¨ë“  ì…€ì˜ íœìŠ¬ ìˆ«ìì™€ ìœ„ì¹˜ ìˆ˜ì§‘
    const pencilMap = new Map(); // ìˆ«ì => ë°°ì—´[ì…€]

    cells.forEach(c => {
      if (!c.classList.contains('pencil')) return;
      const spans = c.querySelectorAll('span');
      spans.forEach(s => {
        const num = s.textContent;
        if (!pencilMap.has(num)) pencilMap.set(num, []);
        pencilMap.get(num).push(s);
      });
    });

    // í•´ë‹¹ ìˆ«ìê°€ 2ê°œ ì´ìƒì´ë©´ ì¤‘ë³µ
    pencilNums.forEach(num => {
      const arr = pencilMap.get(num);
      if (arr && arr.length > 1) {
        // ì´ ìˆ«ìëŠ” ì¤‘ë³µëœ ìˆ«ìì´ë¯€ë¡œ ì´ ì…€ ë‚´ì—ì„œ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ í‘œì‹œ
        pencilSpans.forEach(span => {
          if (span.textContent === num) {
            span.style.color = 'red';
          }
        });
      }
    });
  });
}


let currentScale = 1;

function changeScale(delta) {
  currentScale = Math.min(2, Math.max(0.5, currentScale + delta)); // ìµœì†Œ 50%, ìµœëŒ€ 200%
  const container = document.body; // ë˜ëŠ” .game-container ê°™ì€ ì „ì²´ ìš”ì†Œ
  container.style.transform = `scale(${currentScale})`;
  container.style.transformOrigin = 'top center';
  document.getElementById('scale-display').textContent = `${Math.round(currentScale * 100)}%`;

  // ì„ íƒì‚¬í•­: ë¡œì»¬ ì €ì¥
  localStorage.setItem('sudokuScale', currentScale);
}




    window.addEventListener('DOMContentLoaded', () => {
      if (!loadPuzzleFromQuery()) {
        generateSudoku();
      }
      validatePencilNotes();
      loadGuideToggleState();
      saveState(); // ì´ˆê¸° ìƒíƒœ ì €ì¥ í•„ìˆ˜!
      validateBoard();
    });
  </script>

</body>

</html>